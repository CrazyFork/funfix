/*
 * Copyright (c) 2017 by The Funfix Project Developers.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as eq from "./equals"
import { NoSuchElementError } from "./errors"
import { Option } from "./option"

/**
 * Represents a value of one of two possible types (a disjoint union).
 *
 * A common use of Either is as an alternative to [[Option]] for dealing
 * with possible missing values. In this usage [[Option.none]] is replaced
 * with [[Either.left]] which can contain useful information and
 * [[Option.some]] is replaced with [[Either.right]].
 *
 * Convention dictates that `left` is used for failure and `right` is used
 * for success. Note that this `Either` type is right-biased, meaning that
 * operations such as `map`, `flatMap` and `filter` work on the `right` value
 * and if you want to work on the `left` value, then you need to do a `swap`.
 *
 * For example, you could use `Either<String, Int>` to detect whether an
 * input is a string or an number:
 *
 * ```typescript
 * function tryParseInt(str: string): Either<string, number> {
 *   const i = parseInt(value)
 *   return isNaN(i) ? Either.left(str) : Either.right(i)
 * }
 *
 * const result = tryParseInt("not an int")
 * if (result.isRight) {
 *   console.log(`Increment: ${result.get}`)
 * } else {
 *   console.log(`ERROR: could not parse ${result.swap.get}`)
 * }
 * ```
 *
 * @final
 */
export class Either<A, B> implements eq.IEquals<Either<A, B>> {
  private _isRight: boolean
  private _rightRef: B
  private _leftRef: A

  private constructor(_leftRef: A, _rightRef: B, _isRight: boolean) {
    this._isRight = _isRight
    if (_isRight) this._rightRef = _rightRef
    else this._leftRef = _leftRef
  }

  /**
   * Returns `true` if this is a `left`, `false` otherwise.
   *
   * ```typescript
   * Either.left("hello").isLeft() // true
   * Either.right(10).isLeft() // false
   * ```
   */
  isLeft(): boolean { return !this._isRight }

  /**
   * If the source is a `left` value, then returns it
   * unchanged, otherwise throw exception.
   *
   * @throws NoSuchElementError
   */
  left(): Either<A, never> {
    if (!this._isRight) return (this as any) as Either<A, never>
    throw new NoSuchElementError("either.left")
  }

  /**
   * Returns `true` if this is a `right`, `false` otherwise.
   *
   * ```typescript
   * Either.left("hello").isRight() // false
   * Either.right(10).isRight() // true
   * ```
   */
  isRight(): boolean { return this._isRight }

  /**
   * If the source is a `right` value, then returns it
   * unchanged, otherwise throw exception.
   *
   * @throws NoSuchElementError
   */
  right(): Either<never, B> {
    if (this._isRight) return (this as any) as Either<never, B>
    throw new NoSuchElementError("either.right")
  }

  /**
   * Returns true if this is a Right and its value is equal to `elem`
   * (as determined by the `equals` protocol), returns `false` otherwise.
   *
   * ```typescript
   * // True
   * Either.right("something").contains("something")
   *
   * // False because the values are different
   * Either.right("something").contains("anything") // false
   *
   * // False because the source is a `left`
   * Either.left("something").contains("something") // false
   * ```
   */
  contains(elem: B): boolean {
    return this._isRight && eq.equals(this._rightRef, elem)
  }

  /**
   * Returns `false` if the source is a `left`, or returns the result
   * of the application of the given predicate to the `right` value.
   *
   * ```typescript
   * // True, because it is a right and predicate holds
   * Either.right(20).exists(n => n > 10)
   *
   * // False, because the predicate returns false
   * Either.right(10).exists(n => n % 2 != 0)
   *
   * // False, because it is a left
   * Either.left(10).exists(n => n == 10)
   * ```
   */
  exists(p: (b: B) => boolean): boolean {
    return this._isRight && p(this._rightRef)
  }

  /**
   * Filters `right` values with the given predicate, returning
   * the value generated by `zero` in case the source is a `right`
   * value and the predicate doesn't hold.
   *
   * Possible outcomes:
   *
   *  - Returns the existing value of `right` if this is a `right` value and the
   *    given predicate `p` holds for it
   *  - Returns `left(zero())` if this is a `right` value
   *    and the given predicate `p` does not hold
   *  - Returns the current `left` value, if the source is a `left`
   *
   * ```typescript
   * Either.right(12).filterOrElse(x => x > 10, () => -1) // right(12)
   * Either.right(7).filterOrElse(x => x > 10, () => -1)  // left(-1)
   * Either.left(7).filterOrElse(x => false, () => -1)    // left(7)
   * ```
   */
  filterOrElse(p: (b: B) => boolean, zero: () => A): Either<A, B> {
    return this._isRight
      ? (p(this._rightRef) ? this.right() : Either.left(zero()))
      : this.left()
  }

  /**
   * Binds the given function across `right` values.
   *
   * This operation is the monadic "bind" operation.
   * It can be used to *chain* multiple either references.
   */
  flatMap<Y>(f: (b: B) => Either<A, Y>): Either<A, Y> {
    return this._isRight ? f(this._rightRef) : this.left()
  }

  /**
   * Applies `fa` to `left` values, or `fb` to `right` values
   * and returns the result.
   *
   * ```typescript
   * const maybeNum: Either<string, number> =
   *   tryParseInt("not a number")
   *
   * const result: string =
   *   maybeNum.fold(
   *     str => `Could not parse string: ${str}`,
   *     num => `Success: ${num}`
   *   )
   * ```
   */
  fold<C>(fa: (a: A) => C, fb: (b: B) => C): C {
    return this._isRight ? fb(this._rightRef) : fa(this._leftRef)
  }

  /**
   * Returns true if the source is a `left` or returns
   * the result of the application of the given predicate to the
   * `right` value.
   *
   * ```typescript
   * // True, because it is a `left`
   * Either.left("hello").forAll(x => x > 10)
   *
   * // True, because the predicate holds
   * Either.right(20).forAll(x => x > 10)
   *
   * // False, it's a right and the predicate doesn't hold
   * Either.right(7).forAll(x => x > 10)
   * ```
   */
  forAll(p: (b: B) => boolean): boolean {
    return !this._isRight || p(this._rightRef)
  }

  /**
   * Returns the value from this `right` or a fallback
   * `or` value if this is a `left`.
   *
   * ```typescript
   * Either.right(10).getOrElse(27) // 10
   * Either.left(10).getOrElse(27)  // 27
   * ```
   */
  getOrElse(or: B): B {
    return this._isRight ? this._rightRef : or
  }

  /**
   * Returns the value from this `right` or a value generated
   * by the given `thunk` if this is a `left`.
   *
   * ```typescript
   * Either.right(10).getOrElseL(() => 27) // 10
   * Either.left(10).getOrElseL(() => 27)  // 27
   * ```
   */
  getOrElseL(thunk: () => B): B {
    return this._isRight ? this._rightRef : thunk()
  }

  /**
   * Transform the source if it is a `right` with the given
   * mapping function.
   *
   * ```typescript
   * Either.right(10).map(x => x + 17) // right(27)
   * Either.left(10).map(x => x + 17)  // left(10)
   * ```
   */
  map<C>(f: (b: B) => C): Either<A, C> {
    return this._isRight
      ? Either.right(f(this._rightRef))
      : this.left()
  }

  /**
   * Executes the given side-effecting function if the
   * source is a `right` value.
   *
   * ```typescript
   * Either.right(12).forAll(console.log) // prints 12
   * Either.left(10).forAll(console.log)  // silent
   * ```
   */
  forEach(cb: (b: B) => void): void {
    if (this._isRight) cb(this._rightRef)
  }

  /**
   * If this is a `left`, then return the left value as a `right`
   * or vice versa.
   *
   * ```typescript
   * Either.right(10).swap() // left(10)
   * Either.left(20).swap()  // right(20)
   * ```
   */
  swap(): Either<B, A> {
    return this._isRight
      ? Either.left(this._rightRef)
      : Either.right(this._leftRef)
  }

  /**
   * Returns an `Option.some(right)` if the source is a `right` value,
   * or `Option.none` in case the source is a `left` value.
   */
  toOption(): Option<B> {
    return this._isRight
      ? Option.some(this._rightRef)
      : Option.none()
  }

  // Implemented from IEquals
  equals(other: Either<A, B>): boolean {
    // tslint:disable-next-line:strict-type-predicates
    if (other == null) return false
    if (this._isRight) return eq.equals(this._rightRef, other._rightRef)
    return eq.equals(this._leftRef, other._leftRef)
  }

  // Implemented from IEquals
  hashCode(): number {
    return this._isRight
      ? eq.hashCode(this._rightRef) << 2
      : eq.hashCode(this._leftRef) << 3
  }

  static left<A>(value: A): Either<A, never> {
    return new Either(value, null, false) as Either<A, never>
  }

  static right<B>(value: B): Either<never, B> {
    return new Either(null, value, true) as Either<never, B>
  }
}
