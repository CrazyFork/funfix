/**
 * @licence
 * Copyright (c) 2017 by The Funfix Project Developers.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

"use strict"

import * as std from "./std"
import { NoSuchElementError } from "./errors"
import { Option } from "./option"

/**
 * Represents a value of one of two possible types (a disjoint union).
 *
 * A common use of Either is as an alternative to [[Option]] for dealing
 * with possible missing values. In this usage [[Option.none]] is replaced
 * with [[Either.left]] which can contain useful information and
 * [[Option.some]] is replaced with [[Either.right]].
 *
 * Convention dictates that `left` is used for failure and `right` is used
 * for success. Note that this `Either` type is right-biased, meaning that
 * operations such as `map`, `flatMap` and `filter` work on the `right` value
 * and if you want to work on the `left` value, then you need to do a `swap`.
 *
 * For example, you could use `Either<String, Int>` to detect whether an
 * input is a string or an number:
 *
 * ```typescript
 * function tryParseInt(str: string): Either<string, number> {
 *   const i = parseInt(value)
 *   return isNaN(i) ? Left.of(str) : Right.of(i)
 * }
 *
 * const result = tryParseInt("not an int")
 * if (result.isRight()) {
 *   console.log(`Increment: ${result.get}`)
 * } else {
 *   console.log(`ERROR: could not parse ${result.swap.get}`)
 * }
 * ```
 *
 * @final
 */
export class Either<L, R> implements std.IEquals<Either<L, R>> {
  private _isRight: boolean
  private _rightRef: R
  private _leftRef: L

  protected constructor(_leftRef: L, _rightRef: R, _isRight: boolean) {
    std.checkSumType(this, Left, Right)
    this._isRight = _isRight
    if (_isRight) this._rightRef = _rightRef
    else this._leftRef = _leftRef
  }

  /**
   * Returns `true` if this is a `left`, `false` otherwise.
   *
   * ```typescript
   * Left.of("hello").isLeft() // true
   * Right.of(10).isLeft() // false
   * ```
   */
  isLeft(): boolean { return !this._isRight }

  /**
   * If the source is a `left` value, then returns it unchanged
   * and casted as a `Left`, otherwise throw exception.
   *
   * WARNING!
   *
   * This function is partial, the reference must be a `Left,
   * otherwise a runtime exception will get thrown. Use with care.
   *
   * @throws NoSuchElementError
   */
  left(): Left<L> {
    if (!this._isRight) return (this as any) as Left<L>
    throw new NoSuchElementError("either.left")
  }

  /**
   * Returns `true` if this is a `right`, `false` otherwise.
   *
   * ```typescript
   * Left.of("hello").isRight() // false
   * Right.of(10).isRight() // true
   * ```
   */
  isRight(): boolean { return this._isRight }

  /**
   * If the source is a `right` value, then returns it unchanged
   * and casted as a `Right`, otherwise throw exception.
   *
   * WARNING!
   *
   * This function is partial, the reference must be a `Right,
   * otherwise a runtime exception will get thrown. Use with care.
   *
   * @throws NoSuchElementError
   */
  right(): Right<R> {
    if (this._isRight) return (this as any) as Right<R>
    throw new NoSuchElementError("either.right")
  }

  /**
   * Returns true if this is a Right and its value is equal to `elem`
   * (as determined by the `equals` protocol), returns `false` otherwise.
   *
   * ```typescript
   * // True
   * Right.of("something").contains("something")
   *
   * // False because the values are different
   * Right.of("something").contains("anything") // false
   *
   * // False because the source is a `left`
   * Left.of("something").contains("something") // false
   * ```
   */
  contains(elem: R): boolean {
    return this._isRight && std.is(this._rightRef, elem)
  }

  /**
   * Returns `false` if the source is a `left`, or returns the result
   * of the application of the given predicate to the `right` value.
   *
   * ```typescript
   * // True, because it is a right and predicate holds
   * Right.of(20).exists(n => n > 10)
   *
   * // False, because the predicate returns false
   * Right.of(10).exists(n => n % 2 != 0)
   *
   * // False, because it is a left
   * Left.of(10).exists(n => n == 10)
   * ```
   */
  exists(p: (r: R) => boolean): boolean {
    return this._isRight && p(this._rightRef)
  }

  /**
   * Filters `right` values with the given predicate, returning
   * the value generated by `zero` in case the source is a `right`
   * value and the predicate doesn't hold.
   *
   * Possible outcomes:
   *
   *  - Returns the existing value of `right` if this is a `right` value and the
   *    given predicate `p` holds for it
   *  - Returns `Left(zero())` if this is a `right` value
   *    and the given predicate `p` does not hold
   *  - Returns the current "left" value, if the source is a `Left`
   *
   * ```typescript
   * Right(12).filterOrElse(x => x > 10, () => -1) // Right(12)
   * Right(7).filterOrElse(x => x > 10, () => -1)  // Left(-1)
   * Left(7).filterOrElse(x => false, () => -1)    // Left(7)
   * ```
   */
  filterOrElse(p: (r: R) => boolean, zero: () => L): Either<L, R> {
    return this._isRight
      ? (p(this._rightRef) ? this.right() : Left.of(zero()))
      : this.left()
  }

  /**
   * Binds the given function across `right` values.
   *
   * This operation is the monadic "bind" operation.
   * It can be used to *chain* multiple `Either` references.
   */
  flatMap<S>(f: (r: R) => Either<L, S>): Either<L, S> {
    return this._isRight ? f(this._rightRef) : this.left()
  }

  /**
   * Applies the `left` function to [[Left]] values, and the
   * `right` function to [[Right]] values and returns the result.
   *
   * ```typescript
   * const maybeNum: Either<string, number> =
   *   tryParseInt("not a number")
   *
   * const result: string =
   *   maybeNum.fold(
   *     str => `Could not parse string: ${str}`,
   *     num => `Success: ${num}`
   *   )
   * ```
   */
  fold<S>(left: (l: L) => S, right: (r: R) => S): S {
    return this._isRight ? right(this._rightRef) : left(this._leftRef)
  }

  /**
   * Returns true if the source is a `left` or returns
   * the result of the application of the given predicate to the
   * `right` value.
   *
   * ```typescript
   * // True, because it is a `left`
   * Left.of("hello").forAll(x => x > 10)
   *
   * // True, because the predicate holds
   * Right.of(20).forAll(x => x > 10)
   *
   * // False, it's a right and the predicate doesn't hold
   * Right.of(7).forAll(x => x > 10)
   * ```
   */
  forAll(p: (r: R) => boolean): boolean {
    return !this._isRight || p(this._rightRef)
  }

  /**
   * Returns the `Right` value, if the source has one,
   * otherwise throws an exception.
   *
   * WARNING!
   *
   * This function is partial, the `Either` must be a `Right`, otherwise
   * a runtime exception will get thrown. Use with care.
   *
   * @throws [[NoSuchElementError]] in case the the `Either` is a `Left`
   */
  get(): R {
    if (this._isRight) return this._rightRef
    throw new NoSuchElementError("left.get()")
  }

  /**
   * Returns the value from this `right` or a fallback
   * `or` value if this is a `left`.
   *
   * ```typescript
   * Right.of(10).getOrElse(27) // 10
   * Left.of(10).getOrElse(27)  // 27
   * ```
   */
  getOrElse(or: R): R {
    return this._isRight ? this._rightRef : or
  }

  /**
   * Returns the value from this `right` or a value generated
   * by the given `thunk` if this is a `left`.
   *
   * ```typescript
   * Right.of(10).getOrElseL(() => 27) // 10
   * Left.of(10).getOrElseL(() => 27)  // 27
   * ```
   */
  getOrElseL(thunk: () => R): R {
    return this._isRight ? this._rightRef : thunk()
  }

  /**
   * Transform the source if it is a `right` with the given
   * mapping function.
   *
   * ```typescript
   * Right.of(10).map(x => x + 17) // right(27)
   * Left.of(10).map(x => x + 17)  // left(10)
   * ```
   */
  map<C>(f: (r: R) => C): Either<L, C> {
    return this._isRight
      ? Right.of(f(this._rightRef))
      : this.left()
  }

  /**
   * Executes the given side-effecting function if the
   * source is a `right` value.
   *
   * ```typescript
   * Right.of(12).forAll(console.log) // prints 12
   * Left.of(10).forAll(console.log)  // silent
   * ```
   */
  forEach(cb: (r: R) => void): void {
    if (this._isRight) cb(this._rightRef)
  }

  /**
   * If this is a `left`, then return the left value as a `right`
   * or vice versa.
   *
   * ```typescript
   * Right.of(10).swap() // left(10)
   * Left.of(20).swap()  // right(20)
   * ```
   */
  swap(): Either<R, L> {
    return this._isRight
      ? Left.of(this._rightRef)
      : Right.of(this._leftRef)
  }

  /**
   * Returns an `Option.some(right)` if the source is a `right` value,
   * or `Option.none` in case the source is a `left` value.
   */
  toOption(): Option<R> {
    return this._isRight
      ? Option.some(this._rightRef)
      : Option.none()
  }

  // Implemented from IEquals
  equals(other: Either<L, R>): boolean {
    // tslint:disable-next-line:strict-type-predicates
    if (other == null) return false
    if (this._isRight) return std.is(this._rightRef, other._rightRef)
    return std.is(this._leftRef, other._leftRef)
  }

  // Implemented from IEquals
  hashCode(): number {
    return this._isRight
      ? std.hashCode(this._rightRef) << 2
      : std.hashCode(this._leftRef) << 3
  }

  static left<L, R>(value: L): Either<L, R> {
    return new Left(value)
  }

  static right<L, R>(value: R): Either<L, R> {
    return new Right(value)
  }
}

/**
 * The `Left` data type represents the left side of the [[Either]]
 * disjoint union, as opposed to the [[Right]] side.
 */
export class Left<L> extends Either<L, never> {
  constructor(value: L) {
    super(value, null as never, false)
  }

  /** Builds a [[Left]] reference by wrapping any value. */
  static of<L>(value: L): Left<L> {
    return new Left(value)
  }
}

/**
 * The `Right` data type represents the left side of the [[Either]]
 * disjoint union, as opposed to the [[Left]] side.
 */
export class Right<R> extends Either<never, R> {
  constructor(value: R) {
    super(null as never, value, true)
  }

  /** Builds a [[Right]] reference by wrapping any value. */
  static of<R>(value: R): Right<R> {
    return new Right(value)
  }
}
